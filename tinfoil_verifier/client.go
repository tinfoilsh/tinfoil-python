/*
cgo stubs for package client.
File is generated by gopy. Do not edit.
gopy build -output=tinfoil_verifier -vm=python3 github.com/tinfoilsh/verifier/client
*/

package main

/*

#cgo CFLAGS: "-I/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13/include/python3.13" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13/lib" "-lpython3.13" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"context"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"fmt"
	"io"
	"math/big"
	"math/rand"
	"mime/multipart"
	"net"
	"net/http"
	"net/textproto"
	"net/url"
	"time"

	"github.com/tinfoilsh/verifier/client"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: client below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *tls.ConnectionState
func ptrFromHandle_Ptr_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_Ptr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tls.ConnectionState", p))
}

// Converters for pointer handles for type: *x509.CertPool
func ptrFromHandle_Ptr_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_Ptr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.CertPool", p))
}

// Converters for pointer handles for type: *x509.Certificate
func ptrFromHandle_Ptr_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.Certificate", p))
}

// Converters for pointer handles for type: *pkix.CertificateList
func ptrFromHandle_Ptr_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_Ptr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.CertificateList", p))
}

// Converters for pointer handles for type: *pkix.RDNSequence
func ptrFromHandle_Ptr_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func handleFromPtr_Ptr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.RDNSequence", p))
}

// Converters for pointer handles for type: *big.Int
func ptrFromHandle_Ptr_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_Ptr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*big.Int", p))
}

// Converters for pointer handles for type: *rand.Rand
func ptrFromHandle_Ptr_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_Ptr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rand.Rand", p))
}

// Converters for pointer handles for type: *multipart.FileHeader
func ptrFromHandle_Ptr_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.FileHeader", p))
}

// Converters for pointer handles for type: *multipart.Form
func ptrFromHandle_Ptr_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_Ptr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Form", p))
}

// Converters for pointer handles for type: *multipart.Part
func ptrFromHandle_Ptr_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_Ptr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Part", p))
}

// Converters for pointer handles for type: *multipart.Reader
func ptrFromHandle_Ptr_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_Ptr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Reader", p))
}

// Converters for pointer handles for type: *net.IPNet
func ptrFromHandle_Ptr_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*net.IPNet", p))
}

// Converters for pointer handles for type: *http.Client
func ptrFromHandle_Ptr_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_Ptr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Client", p))
}

// Converters for pointer handles for type: *http.Cookie
func ptrFromHandle_Ptr_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Cookie", p))
}

// Converters for pointer handles for type: *http.Request
func ptrFromHandle_Ptr_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_Ptr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Request", p))
}

// Converters for pointer handles for type: *http.Response
func ptrFromHandle_Ptr_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_Ptr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Response", p))
}

// Converters for pointer handles for type: *url.URL
func ptrFromHandle_Ptr_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.URL", p))
}

// Converters for pointer handles for type: *url.Userinfo
func ptrFromHandle_Ptr_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_Ptr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.Userinfo", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for non-pointer handles for type: tls.ConnectionState
func ptrFromHandle_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.ConnectionState", p))
}

// Converters for non-pointer handles for type: x509.CertPool
func ptrFromHandle_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.CertPool", p))
}

// Converters for non-pointer handles for type: x509.Certificate
func ptrFromHandle_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.Certificate", p))
}

// Converters for non-pointer handles for type: x509.OID
func ptrFromHandle_x509_OID(h CGoHandle) *x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.OID")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.OID{})).(*x509.OID)
}
func handleFromPtr_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.OID", p))
}

// Converters for non-pointer handles for type: x509.VerifyOptions
func ptrFromHandle_x509_VerifyOptions(h CGoHandle) *x509.VerifyOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.VerifyOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.VerifyOptions{})).(*x509.VerifyOptions)
}
func handleFromPtr_x509_VerifyOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.VerifyOptions", p))
}

// Converters for non-pointer handles for type: pkix.AlgorithmIdentifier
func ptrFromHandle_pkix_AlgorithmIdentifier(h CGoHandle) *pkix.AlgorithmIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AlgorithmIdentifier")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AlgorithmIdentifier{})).(*pkix.AlgorithmIdentifier)
}
func handleFromPtr_pkix_AlgorithmIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AlgorithmIdentifier", p))
}

// Converters for non-pointer handles for type: pkix.AttributeTypeAndValue
func ptrFromHandle_pkix_AttributeTypeAndValue(h CGoHandle) *pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AttributeTypeAndValue{})).(*pkix.AttributeTypeAndValue)
}
func handleFromPtr_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AttributeTypeAndValue", p))
}

// Converters for non-pointer handles for type: pkix.CertificateList
func ptrFromHandle_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.CertificateList", p))
}

// Converters for non-pointer handles for type: pkix.Extension
func ptrFromHandle_pkix_Extension(h CGoHandle) *pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Extension")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Extension{})).(*pkix.Extension)
}
func handleFromPtr_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Extension", p))
}

// Converters for non-pointer handles for type: pkix.Name
func ptrFromHandle_pkix_Name(h CGoHandle) *pkix.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Name{})).(*pkix.Name)
}
func handleFromPtr_pkix_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Name", p))
}

// Converters for implicit pointer handles for type: pkix.RDNSequence
func ptrFromHandle_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func deptrFromHandle_pkix_RDNSequence(h CGoHandle) pkix.RDNSequence {
	p := ptrFromHandle_pkix_RDNSequence(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RDNSequence", p))
}

// Converters for implicit pointer handles for type: pkix.RelativeDistinguishedNameSET
func ptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) *pkix.RelativeDistinguishedNameSET {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RelativeDistinguishedNameSET")
	if p == nil {
		return nil
	}
	return p.(*pkix.RelativeDistinguishedNameSET)
}
func deptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) pkix.RelativeDistinguishedNameSET {
	p := ptrFromHandle_pkix_RelativeDistinguishedNameSET(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RelativeDistinguishedNameSET(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RelativeDistinguishedNameSET", p))
}

// --- wrapping slice: pkix.RelativeDistinguishedNameSET ---
//
//export pkix_RelativeDistinguishedNameSET_CTor
func pkix_RelativeDistinguishedNameSET_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&pkix.RelativeDistinguishedNameSET{}))
}

//export pkix_RelativeDistinguishedNameSET_len
func pkix_RelativeDistinguishedNameSET_len(handle CGoHandle) int {
	return len(deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle))
}

//export pkix_RelativeDistinguishedNameSET_elem
func pkix_RelativeDistinguishedNameSET_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export pkix_RelativeDistinguishedNameSET_subslice
func pkix_RelativeDistinguishedNameSET_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&ss))
}

//export pkix_RelativeDistinguishedNameSET_set
func pkix_RelativeDistinguishedNameSET_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export pkix_RelativeDistinguishedNameSET_append
func pkix_RelativeDistinguishedNameSET_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for non-pointer handles for type: pkix.RevokedCertificate
func ptrFromHandle_pkix_RevokedCertificate(h CGoHandle) *pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.RevokedCertificate{})).(*pkix.RevokedCertificate)
}
func handleFromPtr_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RevokedCertificate", p))
}

// Converters for non-pointer handles for type: pkix.TBSCertificateList
func ptrFromHandle_pkix_TBSCertificateList(h CGoHandle) *pkix.TBSCertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.TBSCertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.TBSCertificateList{})).(*pkix.TBSCertificateList)
}
func handleFromPtr_pkix_TBSCertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.TBSCertificateList", p))
}

// Converters for non-pointer handles for type: asn1.BitString
func ptrFromHandle_asn1_BitString(h CGoHandle) *asn1.BitString {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.BitString")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.BitString{})).(*asn1.BitString)
}
func handleFromPtr_asn1_BitString(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.BitString", p))
}

// Converters for implicit pointer handles for type: asn1.ObjectIdentifier
func ptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) *asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*asn1.ObjectIdentifier)
}
func deptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) asn1.ObjectIdentifier {
	p := ptrFromHandle_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.ObjectIdentifier", p))
}

// --- wrapping slice: asn1.ObjectIdentifier ---
//
//export asn1_ObjectIdentifier_CTor
func asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&asn1.ObjectIdentifier{}))
}

//export asn1_ObjectIdentifier_len
func asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_ObjectIdentifier(handle))
}

//export asn1_ObjectIdentifier_elem
func asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	return C.longlong(s[_idx])
}

//export asn1_ObjectIdentifier_subslice
func asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&ss))
}

//export asn1_ObjectIdentifier_set
func asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	s[_idx] = int(_vl)
}

//export asn1_ObjectIdentifier_append
func asn1_ObjectIdentifier_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_asn1_ObjectIdentifier(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: asn1.RawContent
func ptrFromHandle_asn1_RawContent(h CGoHandle) *asn1.RawContent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawContent")
	if p == nil {
		return nil
	}
	return p.(*asn1.RawContent)
}
func deptrFromHandle_asn1_RawContent(h CGoHandle) asn1.RawContent {
	p := ptrFromHandle_asn1_RawContent(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_RawContent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawContent", p))
}

// --- wrapping slice: asn1.RawContent ---
//
//export asn1_RawContent_CTor
func asn1_RawContent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_RawContent(&asn1.RawContent{}))
}

//export asn1_RawContent_len
func asn1_RawContent_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_RawContent(handle))
}

//export asn1_RawContent_elem
func asn1_RawContent_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_asn1_RawContent(handle)
	return C.char(s[_idx])
}

//export asn1_RawContent_subslice
func asn1_RawContent_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_RawContent(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_RawContent(&ss))
}

//export asn1_RawContent_set
func asn1_RawContent_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_asn1_RawContent(handle)
	s[_idx] = byte(_vl)
}

//export asn1_RawContent_append
func asn1_RawContent_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_asn1_RawContent(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: asn1.RawValue
func ptrFromHandle_asn1_RawValue(h CGoHandle) *asn1.RawValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.RawValue{})).(*asn1.RawValue)
}
func handleFromPtr_asn1_RawValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawValue", p))
}

// Converters for pointer handles for type: fmt.ScanState
func ptrFromHandle_fmt_ScanState(h CGoHandle) fmt.ScanState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.ScanState")
	if p == nil {
		return nil
	}
	return p.(fmt.ScanState)
}
func handleFromPtr_fmt_ScanState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.ScanState", p))
}

// Converters for pointer handles for type: fmt.State
func ptrFromHandle_fmt_State(h CGoHandle) fmt.State {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.State")
	if p == nil {
		return nil
	}
	return p.(fmt.State)
}
func handleFromPtr_fmt_State(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.State", p))
}

// Converters for pointer handles for type: io.ReadCloser
func ptrFromHandle_io_ReadCloser(h CGoHandle) io.ReadCloser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.ReadCloser")
	if p == nil {
		return nil
	}
	return p.(io.ReadCloser)
}
func handleFromPtr_io_ReadCloser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.ReadCloser", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for non-pointer handles for type: big.Int
func ptrFromHandle_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("big.Int", p))
}

// Converters for non-pointer handles for type: rand.Rand
func ptrFromHandle_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rand.Rand", p))
}

// Converters for pointer handles for type: multipart.File
func ptrFromHandle_multipart_File(h CGoHandle) multipart.File {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.File")
	if p == nil {
		return nil
	}
	return p.(multipart.File)
}
func handleFromPtr_multipart_File(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.File", p))
}

// Converters for non-pointer handles for type: multipart.FileHeader
func ptrFromHandle_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.FileHeader", p))
}

// Converters for non-pointer handles for type: multipart.Form
func ptrFromHandle_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Form", p))
}

// Converters for non-pointer handles for type: multipart.Part
func ptrFromHandle_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Part", p))
}

// Converters for non-pointer handles for type: multipart.Reader
func ptrFromHandle_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Reader", p))
}

// Converters for implicit pointer handles for type: net.IP
func ptrFromHandle_net_IP(h CGoHandle) *net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IP")
	if p == nil {
		return nil
	}
	return p.(*net.IP)
}
func deptrFromHandle_net_IP(h CGoHandle) net.IP {
	p := ptrFromHandle_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IP", p))
}

// --- wrapping slice: net.IP ---
//
//export net_IP_CTor
func net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IP(&net.IP{}))
}

//export net_IP_len
func net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IP(handle))
}

//export net_IP_elem
func net_IP_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IP(handle)
	return C.char(s[_idx])
}

//export net_IP_subslice
func net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IP(&ss))
}

//export net_IP_set
func net_IP_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IP(handle)
	s[_idx] = byte(_vl)
}

//export net_IP_append
func net_IP_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IP(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: net.IPMask
func ptrFromHandle_net_IPMask(h CGoHandle) *net.IPMask {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPMask")
	if p == nil {
		return nil
	}
	return p.(*net.IPMask)
}
func deptrFromHandle_net_IPMask(h CGoHandle) net.IPMask {
	p := ptrFromHandle_net_IPMask(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IPMask(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPMask", p))
}

// --- wrapping slice: net.IPMask ---
//
//export net_IPMask_CTor
func net_IPMask_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IPMask(&net.IPMask{}))
}

//export net_IPMask_len
func net_IPMask_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IPMask(handle))
}

//export net_IPMask_elem
func net_IPMask_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IPMask(handle)
	return C.char(s[_idx])
}

//export net_IPMask_subslice
func net_IPMask_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IPMask(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IPMask(&ss))
}

//export net_IPMask_set
func net_IPMask_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IPMask(handle)
	s[_idx] = byte(_vl)
}

//export net_IPMask_append
func net_IPMask_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IPMask(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: net.IPNet
func ptrFromHandle_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPNet", p))
}

// Converters for non-pointer handles for type: http.Client
func ptrFromHandle_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Client", p))
}

// Converters for non-pointer handles for type: http.Cookie
func ptrFromHandle_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Cookie", p))
}

// Converters for pointer handles for type: http.CookieJar
func ptrFromHandle_http_CookieJar(h CGoHandle) http.CookieJar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.CookieJar")
	if p == nil {
		return nil
	}
	return p.(http.CookieJar)
}
func handleFromPtr_http_CookieJar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.CookieJar", p))
}

// Converters for implicit pointer handles for type: http.Header
func ptrFromHandle_http_Header(h CGoHandle) *http.Header {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Header")
	if p == nil {
		return nil
	}
	return p.(*http.Header)
}
func deptrFromHandle_http_Header(h CGoHandle) http.Header {
	p := ptrFromHandle_http_Header(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_http_Header(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Header", p))
}

// --- wrapping map: http.Header ---
//
//export http_Header_CTor
func http_Header_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_http_Header(&http.Header{}))
}

//export http_Header_len
func http_Header_len(handle CGoHandle) int {
	return len(deptrFromHandle_http_Header(handle))
}

//export http_Header_elem
func http_Header_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export http_Header_contains
func http_Header_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_http_Header(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export http_Header_set
func http_Header_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_http_Header(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export http_Header_delete
func http_Header_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_http_Header(handle)
	delete(s, C.GoString(_ky))
}

//export http_Header_keys
func http_Header_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: http.Request
func ptrFromHandle_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Request", p))
}

// Converters for non-pointer handles for type: http.Response
func ptrFromHandle_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Response", p))
}

// Converters for pointer handles for type: http.RoundTripper
func ptrFromHandle_http_RoundTripper(h CGoHandle) http.RoundTripper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.RoundTripper")
	if p == nil {
		return nil
	}
	return p.(http.RoundTripper)
}
func handleFromPtr_http_RoundTripper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.RoundTripper", p))
}

// Converters for implicit pointer handles for type: textproto.MIMEHeader
func ptrFromHandle_textproto_MIMEHeader(h CGoHandle) *textproto.MIMEHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "textproto.MIMEHeader")
	if p == nil {
		return nil
	}
	return p.(*textproto.MIMEHeader)
}
func deptrFromHandle_textproto_MIMEHeader(h CGoHandle) textproto.MIMEHeader {
	p := ptrFromHandle_textproto_MIMEHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_textproto_MIMEHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("textproto.MIMEHeader", p))
}

// --- wrapping map: textproto.MIMEHeader ---
//
//export textproto_MIMEHeader_CTor
func textproto_MIMEHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_textproto_MIMEHeader(&textproto.MIMEHeader{}))
}

//export textproto_MIMEHeader_len
func textproto_MIMEHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_textproto_MIMEHeader(handle))
}

//export textproto_MIMEHeader_elem
func textproto_MIMEHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export textproto_MIMEHeader_contains
func textproto_MIMEHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export textproto_MIMEHeader_set
func textproto_MIMEHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export textproto_MIMEHeader_delete
func textproto_MIMEHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	delete(s, C.GoString(_ky))
}

//export textproto_MIMEHeader_keys
func textproto_MIMEHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: url.URL
func ptrFromHandle_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.URL", p))
}

// Converters for non-pointer handles for type: url.Userinfo
func ptrFromHandle_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Userinfo", p))
}

// Converters for implicit pointer handles for type: url.Values
func ptrFromHandle_url_Values(h CGoHandle) *url.Values {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Values")
	if p == nil {
		return nil
	}
	return p.(*url.Values)
}
func deptrFromHandle_url_Values(h CGoHandle) url.Values {
	p := ptrFromHandle_url_Values(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_url_Values(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Values", p))
}

// --- wrapping map: url.Values ---
//
//export url_Values_CTor
func url_Values_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_url_Values(&url.Values{}))
}

//export url_Values_len
func url_Values_len(handle CGoHandle) int {
	return len(deptrFromHandle_url_Values(handle))
}

//export url_Values_elem
func url_Values_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export url_Values_contains
func url_Values_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_url_Values(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export url_Values_set
func url_Values_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_url_Values(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export url_Values_delete
func url_Values_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_url_Values(handle)
	delete(s, C.GoString(_ky))
}

//export url_Values_keys
func url_Values_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: client ---

// ---- Types ---

// Converters for pointer handles for type: *client.GroundTruth
func ptrFromHandle_Ptr_client_GroundTruth(h CGoHandle) *client.GroundTruth {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.GroundTruth")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.GroundTruth{})).(*client.GroundTruth)
}
func handleFromPtr_Ptr_client_GroundTruth(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.GroundTruth", p))
}

// Converters for pointer handles for type: *client.Response
func ptrFromHandle_Ptr_client_Response(h CGoHandle) *client.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.Response{})).(*client.Response)
}
func handleFromPtr_Ptr_client_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.Response", p))
}

// Converters for pointer handles for type: *client.SecureClient
func ptrFromHandle_Ptr_client_SecureClient(h CGoHandle) *client.SecureClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.SecureClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SecureClient{})).(*client.SecureClient)
}
func handleFromPtr_Ptr_client_SecureClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.SecureClient", p))
}

// Converters for pointer handles for type: *client.TLSBoundRoundTripper
func ptrFromHandle_Ptr_client_TLSBoundRoundTripper(h CGoHandle) *client.TLSBoundRoundTripper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.TLSBoundRoundTripper")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.TLSBoundRoundTripper{})).(*client.TLSBoundRoundTripper)
}
func handleFromPtr_Ptr_client_TLSBoundRoundTripper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.TLSBoundRoundTripper", p))
}

// Converters for implicit pointer handles for type: []*x509.Certificate
func ptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) *[]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[]*x509.Certificate)
}
func deptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) []*x509.Certificate {
	p := ptrFromHandle_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*x509.Certificate", p))
}

// --- wrapping slice: []*x509.Certificate ---
//
//export Slice_Ptr_x509_Certificate_CTor
func Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&[]*x509.Certificate{}))
}

//export Slice_Ptr_x509_Certificate_len
func Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Ptr_x509_Certificate_elem
func Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Ptr_x509_Certificate_subslice
func Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Ptr_x509_Certificate_set
func Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = ptrFromHandle_Ptr_x509_Certificate(_vl)
}

//export Slice_Ptr_x509_Certificate_append
func Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, ptrFromHandle_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: []*multipart.FileHeader
func ptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) *[]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*[]*multipart.FileHeader)
}
func deptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) []*multipart.FileHeader {
	p := ptrFromHandle_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*multipart.FileHeader", p))
}

// --- wrapping slice: []*multipart.FileHeader ---
//
//export Slice_Ptr_multipart_FileHeader_CTor
func Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&[]*multipart.FileHeader{}))
}

//export Slice_Ptr_multipart_FileHeader_len
func Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle))
}

//export Slice_Ptr_multipart_FileHeader_elem
func Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	return handleFromPtr_Ptr_multipart_FileHeader(&(s[_idx]))
}

//export Slice_Ptr_multipart_FileHeader_subslice
func Slice_Ptr_multipart_FileHeader_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&ss))
}

//export Slice_Ptr_multipart_FileHeader_set
func Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	s[_idx] = ptrFromHandle_Ptr_multipart_FileHeader(_vl)
}

//export Slice_Ptr_multipart_FileHeader_append
func Slice_Ptr_multipart_FileHeader_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	*s = append(*s, ptrFromHandle_Ptr_multipart_FileHeader(_vl))
}

// Converters for implicit pointer handles for type: []*net.IPNet
func ptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) *[]*net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*net.IPNet")
	if p == nil {
		return nil
	}
	return p.(*[]*net.IPNet)
}
func deptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) []*net.IPNet {
	p := ptrFromHandle_Slice_Ptr_net_IPNet(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*net.IPNet", p))
}

// --- wrapping slice: []*net.IPNet ---
//
//export Slice_Ptr_net_IPNet_CTor
func Slice_Ptr_net_IPNet_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&[]*net.IPNet{}))
}

//export Slice_Ptr_net_IPNet_len
func Slice_Ptr_net_IPNet_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_net_IPNet(handle))
}

//export Slice_Ptr_net_IPNet_elem
func Slice_Ptr_net_IPNet_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	return handleFromPtr_Ptr_net_IPNet(&(s[_idx]))
}

//export Slice_Ptr_net_IPNet_subslice
func Slice_Ptr_net_IPNet_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&ss))
}

//export Slice_Ptr_net_IPNet_set
func Slice_Ptr_net_IPNet_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	s[_idx] = ptrFromHandle_Ptr_net_IPNet(_vl)
}

//export Slice_Ptr_net_IPNet_append
func Slice_Ptr_net_IPNet_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_net_IPNet(handle)
	*s = append(*s, ptrFromHandle_Ptr_net_IPNet(_vl))
}

// Converters for implicit pointer handles for type: []*http.Cookie
func ptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) *[]*http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*http.Cookie")
	if p == nil {
		return nil
	}
	return p.(*[]*http.Cookie)
}
func deptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) []*http.Cookie {
	p := ptrFromHandle_Slice_Ptr_http_Cookie(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*http.Cookie", p))
}

// --- wrapping slice: []*http.Cookie ---
//
//export Slice_Ptr_http_Cookie_CTor
func Slice_Ptr_http_Cookie_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&[]*http.Cookie{}))
}

//export Slice_Ptr_http_Cookie_len
func Slice_Ptr_http_Cookie_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_http_Cookie(handle))
}

//export Slice_Ptr_http_Cookie_elem
func Slice_Ptr_http_Cookie_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	return handleFromPtr_Ptr_http_Cookie(&(s[_idx]))
}

//export Slice_Ptr_http_Cookie_subslice
func Slice_Ptr_http_Cookie_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&ss))
}

//export Slice_Ptr_http_Cookie_set
func Slice_Ptr_http_Cookie_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	s[_idx] = ptrFromHandle_Ptr_http_Cookie(_vl)
}

//export Slice_Ptr_http_Cookie_append
func Slice_Ptr_http_Cookie_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_http_Cookie(handle)
	*s = append(*s, ptrFromHandle_Ptr_http_Cookie(_vl))
}

// Converters for implicit pointer handles for type: []*url.URL
func ptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) *[]*url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*url.URL")
	if p == nil {
		return nil
	}
	return p.(*[]*url.URL)
}
func deptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) []*url.URL {
	p := ptrFromHandle_Slice_Ptr_url_URL(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*url.URL", p))
}

// --- wrapping slice: []*url.URL ---
//
//export Slice_Ptr_url_URL_CTor
func Slice_Ptr_url_URL_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&[]*url.URL{}))
}

//export Slice_Ptr_url_URL_len
func Slice_Ptr_url_URL_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_url_URL(handle))
}

//export Slice_Ptr_url_URL_elem
func Slice_Ptr_url_URL_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	return handleFromPtr_Ptr_url_URL(&(s[_idx]))
}

//export Slice_Ptr_url_URL_subslice
func Slice_Ptr_url_URL_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&ss))
}

//export Slice_Ptr_url_URL_set
func Slice_Ptr_url_URL_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	s[_idx] = ptrFromHandle_Ptr_url_URL(_vl)
}

//export Slice_Ptr_url_URL_append
func Slice_Ptr_url_URL_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_url_URL(handle)
	*s = append(*s, ptrFromHandle_Ptr_url_URL(_vl))
}

// Converters for implicit pointer handles for type: [][]*x509.Certificate
func ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) *[][]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[][]*x509.Certificate)
}
func deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) [][]*x509.Certificate {
	p := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]*x509.Certificate", p))
}

// --- wrapping slice: [][]*x509.Certificate ---
//
//export Slice_Slice_Ptr_x509_Certificate_CTor
func Slice_Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&[][]*x509.Certificate{}))
}

//export Slice_Slice_Ptr_x509_Certificate_len
func Slice_Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Slice_Ptr_x509_Certificate_elem
func Slice_Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Slice_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Slice_Ptr_x509_Certificate_subslice
func Slice_Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Slice_Ptr_x509_Certificate_set
func Slice_Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = deptrFromHandle_Slice_Ptr_x509_Certificate(_vl)
}

//export Slice_Slice_Ptr_x509_Certificate_append
func Slice_Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, deptrFromHandle_Slice_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: []x509.ExtKeyUsage
func ptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) *[]x509.ExtKeyUsage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.ExtKeyUsage")
	if p == nil {
		return nil
	}
	return p.(*[]x509.ExtKeyUsage)
}
func deptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) []x509.ExtKeyUsage {
	p := ptrFromHandle_Slice_x509_ExtKeyUsage(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_ExtKeyUsage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.ExtKeyUsage", p))
}

// --- wrapping slice: []x509.ExtKeyUsage ---
//
//export Slice_x509_ExtKeyUsage_CTor
func Slice_x509_ExtKeyUsage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&[]x509.ExtKeyUsage{}))
}

//export Slice_x509_ExtKeyUsage_len
func Slice_x509_ExtKeyUsage_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_ExtKeyUsage(handle))
}

//export Slice_x509_ExtKeyUsage_elem
func Slice_x509_ExtKeyUsage_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	return C.longlong(int(s[_idx]))
}

//export Slice_x509_ExtKeyUsage_subslice
func Slice_x509_ExtKeyUsage_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&ss))
}

//export Slice_x509_ExtKeyUsage_set
func Slice_x509_ExtKeyUsage_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	s[_idx] = x509.ExtKeyUsage(int(_vl))
}

//export Slice_x509_ExtKeyUsage_append
func Slice_x509_ExtKeyUsage_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	*s = append(*s, x509.ExtKeyUsage(int(_vl)))
}

// Converters for implicit pointer handles for type: []x509.OID
func ptrFromHandle_Slice_x509_OID(h CGoHandle) *[]x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.OID")
	if p == nil {
		return nil
	}
	return p.(*[]x509.OID)
}
func deptrFromHandle_Slice_x509_OID(h CGoHandle) []x509.OID {
	p := ptrFromHandle_Slice_x509_OID(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.OID", p))
}

// --- wrapping slice: []x509.OID ---
//
//export Slice_x509_OID_CTor
func Slice_x509_OID_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_OID(&[]x509.OID{}))
}

//export Slice_x509_OID_len
func Slice_x509_OID_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_OID(handle))
}

//export Slice_x509_OID_elem
func Slice_x509_OID_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	return handleFromPtr_x509_OID(&(s[_idx]))
}

//export Slice_x509_OID_subslice
func Slice_x509_OID_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_OID(&ss))
}

//export Slice_x509_OID_set
func Slice_x509_OID_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_x509_OID(handle)
	s[_idx] = *ptrFromHandle_x509_OID(_vl)
}

//export Slice_x509_OID_append
func Slice_x509_OID_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_x509_OID(handle)
	*s = append(*s, *ptrFromHandle_x509_OID(_vl))
}

// Converters for implicit pointer handles for type: []pkix.AttributeTypeAndValue
func ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) *[]pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.AttributeTypeAndValue)
}
func deptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) []pkix.AttributeTypeAndValue {
	p := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.AttributeTypeAndValue", p))
}

// --- wrapping slice: []pkix.AttributeTypeAndValue ---
//
//export Slice_pkix_AttributeTypeAndValue_CTor
func Slice_pkix_AttributeTypeAndValue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&[]pkix.AttributeTypeAndValue{}))
}

//export Slice_pkix_AttributeTypeAndValue_len
func Slice_pkix_AttributeTypeAndValue_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle))
}

//export Slice_pkix_AttributeTypeAndValue_elem
func Slice_pkix_AttributeTypeAndValue_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export Slice_pkix_AttributeTypeAndValue_subslice
func Slice_pkix_AttributeTypeAndValue_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&ss))
}

//export Slice_pkix_AttributeTypeAndValue_set
func Slice_pkix_AttributeTypeAndValue_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export Slice_pkix_AttributeTypeAndValue_append
func Slice_pkix_AttributeTypeAndValue_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for implicit pointer handles for type: []pkix.Extension
func ptrFromHandle_Slice_pkix_Extension(h CGoHandle) *[]pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.Extension")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.Extension)
}
func deptrFromHandle_Slice_pkix_Extension(h CGoHandle) []pkix.Extension {
	p := ptrFromHandle_Slice_pkix_Extension(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.Extension", p))
}

// --- wrapping slice: []pkix.Extension ---
//
//export Slice_pkix_Extension_CTor
func Slice_pkix_Extension_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&[]pkix.Extension{}))
}

//export Slice_pkix_Extension_len
func Slice_pkix_Extension_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_Extension(handle))
}

//export Slice_pkix_Extension_elem
func Slice_pkix_Extension_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	return handleFromPtr_pkix_Extension(&(s[_idx]))
}

//export Slice_pkix_Extension_subslice
func Slice_pkix_Extension_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&ss))
}

//export Slice_pkix_Extension_set
func Slice_pkix_Extension_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	s[_idx] = *ptrFromHandle_pkix_Extension(_vl)
}

//export Slice_pkix_Extension_append
func Slice_pkix_Extension_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_Extension(handle)
	*s = append(*s, *ptrFromHandle_pkix_Extension(_vl))
}

// Converters for implicit pointer handles for type: []pkix.RevokedCertificate
func ptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) *[]pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.RevokedCertificate)
}
func deptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) []pkix.RevokedCertificate {
	p := ptrFromHandle_Slice_pkix_RevokedCertificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.RevokedCertificate", p))
}

// --- wrapping slice: []pkix.RevokedCertificate ---
//
//export Slice_pkix_RevokedCertificate_CTor
func Slice_pkix_RevokedCertificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&[]pkix.RevokedCertificate{}))
}

//export Slice_pkix_RevokedCertificate_len
func Slice_pkix_RevokedCertificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_RevokedCertificate(handle))
}

//export Slice_pkix_RevokedCertificate_elem
func Slice_pkix_RevokedCertificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	return handleFromPtr_pkix_RevokedCertificate(&(s[_idx]))
}

//export Slice_pkix_RevokedCertificate_subslice
func Slice_pkix_RevokedCertificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&ss))
}

//export Slice_pkix_RevokedCertificate_set
func Slice_pkix_RevokedCertificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	s[_idx] = *ptrFromHandle_pkix_RevokedCertificate(_vl)
}

//export Slice_pkix_RevokedCertificate_append
func Slice_pkix_RevokedCertificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	*s = append(*s, *ptrFromHandle_pkix_RevokedCertificate(_vl))
}

// Converters for implicit pointer handles for type: []asn1.ObjectIdentifier
func ptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) *[]asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*[]asn1.ObjectIdentifier)
}
func deptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) []asn1.ObjectIdentifier {
	p := ptrFromHandle_Slice_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]asn1.ObjectIdentifier", p))
}

// --- wrapping slice: []asn1.ObjectIdentifier ---
//
//export Slice_asn1_ObjectIdentifier_CTor
func Slice_asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&[]asn1.ObjectIdentifier{}))
}

//export Slice_asn1_ObjectIdentifier_len
func Slice_asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_asn1_ObjectIdentifier(handle))
}

//export Slice_asn1_ObjectIdentifier_elem
func Slice_asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	return handleFromPtr_asn1_ObjectIdentifier(&(s[_idx]))
}

//export Slice_asn1_ObjectIdentifier_subslice
func Slice_asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&ss))
}

//export Slice_asn1_ObjectIdentifier_set
func Slice_asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	s[_idx] = deptrFromHandle_asn1_ObjectIdentifier(_vl)
}

//export Slice_asn1_ObjectIdentifier_append
func Slice_asn1_ObjectIdentifier_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	*s = append(*s, deptrFromHandle_asn1_ObjectIdentifier(_vl))
}

// Converters for implicit pointer handles for type: []big.Word
func ptrFromHandle_Slice_big_Word(h CGoHandle) *[]big.Word {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]big.Word")
	if p == nil {
		return nil
	}
	return p.(*[]big.Word)
}
func deptrFromHandle_Slice_big_Word(h CGoHandle) []big.Word {
	p := ptrFromHandle_Slice_big_Word(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_big_Word(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]big.Word", p))
}

// --- wrapping slice: []big.Word ---
//
//export Slice_big_Word_CTor
func Slice_big_Word_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_big_Word(&[]big.Word{}))
}

//export Slice_big_Word_len
func Slice_big_Word_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_big_Word(handle))
}

//export Slice_big_Word_elem
func Slice_big_Word_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_big_Word(handle)
	return C.ulonglong(uint(s[_idx]))
}

//export Slice_big_Word_subslice
func Slice_big_Word_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_big_Word(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_big_Word(&ss))
}

//export Slice_big_Word_set
func Slice_big_Word_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_big_Word(handle)
	s[_idx] = big.Word(uint(_vl))
}

//export Slice_big_Word_append
func Slice_big_Word_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_big_Word(handle)
	*s = append(*s, big.Word(uint(_vl)))
}

// Converters for implicit pointer handles for type: []net.IP
func ptrFromHandle_Slice_net_IP(h CGoHandle) *[]net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]net.IP")
	if p == nil {
		return nil
	}
	return p.(*[]net.IP)
}
func deptrFromHandle_Slice_net_IP(h CGoHandle) []net.IP {
	p := ptrFromHandle_Slice_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]net.IP", p))
}

// --- wrapping slice: []net.IP ---
//
//export Slice_net_IP_CTor
func Slice_net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_net_IP(&[]net.IP{}))
}

//export Slice_net_IP_len
func Slice_net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_net_IP(handle))
}

//export Slice_net_IP_elem
func Slice_net_IP_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	return handleFromPtr_net_IP(&(s[_idx]))
}

//export Slice_net_IP_subslice
func Slice_net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_net_IP(&ss))
}

//export Slice_net_IP_set
func Slice_net_IP_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_net_IP(handle)
	s[_idx] = deptrFromHandle_net_IP(_vl)
}

//export Slice_net_IP_append
func Slice_net_IP_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_net_IP(handle)
	*s = append(*s, deptrFromHandle_net_IP(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for non-pointer handles for type: client.GroundTruth
func ptrFromHandle_client_GroundTruth(h CGoHandle) *client.GroundTruth {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.GroundTruth")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.GroundTruth{})).(*client.GroundTruth)
}
func handleFromPtr_client_GroundTruth(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.GroundTruth", p))
}

// Converters for non-pointer handles for type: client.Response
func ptrFromHandle_client_Response(h CGoHandle) *client.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.Response{})).(*client.Response)
}
func handleFromPtr_client_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Response", p))
}

// Converters for non-pointer handles for type: client.SecureClient
func ptrFromHandle_client_SecureClient(h CGoHandle) *client.SecureClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SecureClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SecureClient{})).(*client.SecureClient)
}
func handleFromPtr_client_SecureClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SecureClient", p))
}

// Converters for non-pointer handles for type: client.TLSBoundRoundTripper
func ptrFromHandle_client_TLSBoundRoundTripper(h CGoHandle) *client.TLSBoundRoundTripper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.TLSBoundRoundTripper")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.TLSBoundRoundTripper{})).(*client.TLSBoundRoundTripper)
}
func handleFromPtr_client_TLSBoundRoundTripper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.TLSBoundRoundTripper", p))
}

// Converters for implicit pointer handles for type: map[string][]*multipart.FileHeader
func ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) *map[string][]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*map[string][]*multipart.FileHeader)
}
func deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) map[string][]*multipart.FileHeader {
	p := ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]*multipart.FileHeader", p))
}

// --- wrapping map: map[string][]*multipart.FileHeader ---
//
//export Map_string_Slice_Ptr_multipart_FileHeader_CTor
func Map_string_Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(&map[string][]*multipart.FileHeader{}))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_len
func Map_string_Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_elem
func Map_string_Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_Ptr_multipart_FileHeader(&v)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_contains
func Map_string_Slice_Ptr_multipart_FileHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_set
func Map_string_Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_Ptr_multipart_FileHeader(_vl)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_delete
func Map_string_Slice_Ptr_multipart_FileHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_keys
func Map_string_Slice_Ptr_multipart_FileHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string][]string
func ptrFromHandle_Map_string_Slice_string(h CGoHandle) *map[string][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]string")
	if p == nil {
		return nil
	}
	return p.(*map[string][]string)
}
func deptrFromHandle_Map_string_Slice_string(h CGoHandle) map[string][]string {
	p := ptrFromHandle_Map_string_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]string", p))
}

// --- wrapping map: map[string][]string ---
//
//export Map_string_Slice_string_CTor
func Map_string_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_string(&map[string][]string{}))
}

//export Map_string_Slice_string_len
func Map_string_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_string(handle))
}

//export Map_string_Slice_string_elem
func Map_string_Slice_string_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export Map_string_Slice_string_contains
func Map_string_Slice_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_string_set
func Map_string_Slice_string_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export Map_string_Slice_string_delete
func Map_string_Slice_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_string_keys
func Map_string_Slice_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]bool
func ptrFromHandle_Map_string_bool(h CGoHandle) *map[string]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]bool")
	if p == nil {
		return nil
	}
	return p.(*map[string]bool)
}
func deptrFromHandle_Map_string_bool(h CGoHandle) map[string]bool {
	p := ptrFromHandle_Map_string_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]bool", p))
}

// --- wrapping map: map[string]bool ---
//
//export Map_string_bool_CTor
func Map_string_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_bool(&map[string]bool{}))
}

//export Map_string_bool_len
func Map_string_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_bool(handle))
}

//export Map_string_bool_elem
func Map_string_bool_elem(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return boolGoToPy(v)
}

//export Map_string_bool_contains
func Map_string_bool_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_bool_set
func Map_string_bool_set(handle CGoHandle, _ky *C.char, _vl C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	s[C.GoString(_ky)] = boolPyToGo(_vl)
}

//export Map_string_bool_delete
func Map_string_bool_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_bool_keys
func Map_string_bool_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_bool(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]string
func ptrFromHandle_Map_string_string(h CGoHandle) *map[string]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]string")
	if p == nil {
		return nil
	}
	return p.(*map[string]string)
}
func deptrFromHandle_Map_string_string(h CGoHandle) map[string]string {
	p := ptrFromHandle_Map_string_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]string", p))
}

// --- wrapping map: map[string]string ---
//
//export Map_string_string_CTor
func Map_string_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_string(&map[string]string{}))
}

//export Map_string_string_len
func Map_string_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_string(handle))
}

//export Map_string_string_elem
func Map_string_string_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_string_string_contains
func Map_string_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_string_set
func Map_string_string_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_string_delete
func Map_string_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_string_keys
func Map_string_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: client.TLSBoundRoundTripper ---
//
//export client_TLSBoundRoundTripper_CTor
func client_TLSBoundRoundTripper_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_TLSBoundRoundTripper(&client.TLSBoundRoundTripper{}))
}

//export client_TLSBoundRoundTripper_ExpectedCertFP_Get
func client_TLSBoundRoundTripper_ExpectedCertFP_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_TLSBoundRoundTripper(handle)
	return handleFromPtr_Slice_byte(&op.ExpectedCertFP)
}

//export client_TLSBoundRoundTripper_ExpectedCertFP_Set
func client_TLSBoundRoundTripper_ExpectedCertFP_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_TLSBoundRoundTripper(handle)
	op.ExpectedCertFP = deptrFromHandle_Slice_byte(val)
}

//export client_TLSBoundRoundTripper_RoundTrip
func client_TLSBoundRoundTripper_RoundTrip(_handle CGoHandle, r CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.TLSBoundRoundTripper")
	if __err != nil {
		return handleFromPtr_Ptr_http_Response(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.TLSBoundRoundTripper{})).(*client.TLSBoundRoundTripper).RoundTrip(ptrFromHandle_Ptr_http_Request(r))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_http_Response(nil)
	}
	return handleFromPtr_Ptr_http_Response(cret)
}

// --- wrapping struct: client.GroundTruth ---
//
//export client_GroundTruth_CTor
func client_GroundTruth_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_GroundTruth(&client.GroundTruth{}))
}

//export client_GroundTruth_CertFingerprint_Get
func client_GroundTruth_CertFingerprint_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_GroundTruth(handle)
	return handleFromPtr_Slice_byte(&op.CertFingerprint)
}

//export client_GroundTruth_CertFingerprint_Set
func client_GroundTruth_CertFingerprint_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_GroundTruth(handle)
	op.CertFingerprint = deptrFromHandle_Slice_byte(val)
}

//export client_GroundTruth_Digest_Get
func client_GroundTruth_Digest_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_GroundTruth(handle)
	return C.CString(op.Digest)
}

//export client_GroundTruth_Digest_Set
func client_GroundTruth_Digest_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_GroundTruth(handle)
	op.Digest = C.GoString(val)
}

//export client_GroundTruth_Measurement_Get
func client_GroundTruth_Measurement_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_GroundTruth(handle)
	return C.CString(op.Measurement)
}

//export client_GroundTruth_Measurement_Set
func client_GroundTruth_Measurement_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_GroundTruth(handle)
	op.Measurement = C.GoString(val)
}

// --- wrapping struct: client.Response ---
//
//export client_Response_CTor
func client_Response_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_Response(&client.Response{}))
}

//export client_Response_Status_Get
func client_Response_Status_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_Response(handle)
	return C.CString(op.Status)
}

//export client_Response_Status_Set
func client_Response_Status_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_Response(handle)
	op.Status = C.GoString(val)
}

//export client_Response_StatusCode_Get
func client_Response_StatusCode_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_Response(handle)
	return C.longlong(op.StatusCode)
}

//export client_Response_StatusCode_Set
func client_Response_StatusCode_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_Response(handle)
	op.StatusCode = int(val)
}

//export client_Response_Headers_Get
func client_Response_Headers_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_Response(handle)
	return handleFromPtr_Map_string_Slice_string(&op.Headers)
}

//export client_Response_Headers_Set
func client_Response_Headers_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_Response(handle)
	op.Headers = deptrFromHandle_Map_string_Slice_string(val)
}

//export client_Response_Body_Get
func client_Response_Body_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_Response(handle)
	return handleFromPtr_Slice_byte(&op.Body)
}

//export client_Response_Body_Set
func client_Response_Body_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_Response(handle)
	op.Body = deptrFromHandle_Slice_byte(val)
}

// --- wrapping struct: client.SecureClient ---
//
//export client_SecureClient_CTor
func client_SecureClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_SecureClient(&client.SecureClient{}))
}

//export client_SecureClient_GroundTruth
func client_SecureClient_GroundTruth(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SecureClient")
	if __err != nil {
		return handleFromPtr_Ptr_client_GroundTruth(nil)
	}
	return handleFromPtr_Ptr_client_GroundTruth(gopyh.Embed(vifc, reflect.TypeOf(client.SecureClient{})).(*client.SecureClient).GroundTruth())

}

//export client_SecureClient_Verify
func client_SecureClient_Verify(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SecureClient")
	if __err != nil {
		return handleFromPtr_Ptr_client_GroundTruth(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.SecureClient{})).(*client.SecureClient).Verify()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_client_GroundTruth(nil)
	}
	return handleFromPtr_Ptr_client_GroundTruth(cret)
}

//export client_SecureClient_HTTPClient
func client_SecureClient_HTTPClient(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SecureClient")
	if __err != nil {
		return handleFromPtr_Ptr_http_Client(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.SecureClient{})).(*client.SecureClient).HTTPClient()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_http_Client(nil)
	}
	return handleFromPtr_Ptr_http_Client(cret)
}

//export client_SecureClient_Post
func client_SecureClient_Post(_handle CGoHandle, url *C.char, headers CGoHandle, body CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SecureClient")
	if __err != nil {
		return handleFromPtr_Ptr_client_Response(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.SecureClient{})).(*client.SecureClient).Post(C.GoString(url), deptrFromHandle_Map_string_string(headers), deptrFromHandle_Slice_byte(body))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_client_Response(nil)
	}
	return handleFromPtr_Ptr_client_Response(cret)
}

//export client_SecureClient_Get
func client_SecureClient_Get(_handle CGoHandle, url *C.char, headers CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SecureClient")
	if __err != nil {
		return handleFromPtr_Ptr_client_Response(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.SecureClient{})).(*client.SecureClient).Get(C.GoString(url), deptrFromHandle_Map_string_string(headers))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_client_Response(nil)
	}
	return handleFromPtr_Ptr_client_Response(cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export client_NewSecureClient
func client_NewSecureClient(enclave *C.char, repo *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_client_SecureClient(client.NewSecureClient(C.GoString(enclave), C.GoString(repo)))

}

// ---- Functions ---
